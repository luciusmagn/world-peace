token Dec='dec'
      Ret='ret'
      End='end'
      Do='do'
      By='by'
      Case='case'
      Num='num'
      Load='load'
      If='if'
      Else='else'
      Until='-->'
      PatternArrow='<-'
      Spacer='---';

token LPar='(' RPar=')' Comma=',' Colon=':' LBrace='{' RBrace='}' Period='.'
      Semi=';' Asn='=' Plus='+' Minus='-' Star='*' Slash='/' Not='!'
      Caret='^' LAng='<' RAng='>' And='&' Percent='%' Pipe='|' LBracket='['
      RBracket=']' DoubleDot='..' Underscore='_'
      Equal='==' NotEqual='!=' LessEqual='<=' GreaterEqual='>='
      LeftShift='<<' RightShift='>>' LogicalAnd='&&' LogicalOr='||'
      RightShiftAssign='>>=' LeftShiftAssign='<<=' MinusAssign='-='
      PlusAssign='+=' XorAssign='^=' DivAssign='/=' MulAssign='*='
      OrAssign='|=' AndAssign='&='
      ;

token Name='<name>' Integer='<integer>' Url='<url>';

token Whitespace;

skip Whitespace;

start file;

file: item*;

item:
     load_stmt
   | variable
   | function
   ;

load_stmt: 'load' source ';';

source:
     Name
   | Url
   ;

variable:
     'num' Name '=' expr ';'
     ;

function:
     'dec' Name param_list ':' body end_expr
     ;

param_list:
     '(' [param (',' param)*] ')'
     ;

param:
     'num' Name
     ;

body:
    ( '---' [ statement ] )*
    ;

end_expr:
    'end' '{' end_body '}'
    ;

end_body:
 ?1 pattern_match
  | expr
    ;

pattern_match:
    match_arm match_arm*
    ;

match_arm:
    expr '<-' pattern ':' stmt_list ','
    ;

pattern:
      pattern_single
    | pattern_array
    ;

pattern_single:
      Integer
    | Name
    | '..'
    | '_'
    ;

pattern_array: '[' pattern_list ']';

pattern_list: pattern_single (',' pattern_single)*;

expr:
    logical_or_expr
    ;

logical_or_expr:
    logical_and_expr ('||' logical_and_expr)*
    ;

logical_and_expr:
    bitwise_or_expr ('&&' bitwise_or_expr)*
    ;

bitwise_or_expr:
    bitwise_xor_expr ('|' bitwise_xor_expr)*
    ;

bitwise_xor_expr:
    bitwise_and_expr ('^' bitwise_and_expr)*
    ;

bitwise_and_expr:
    equality_expr ('&' equality_expr)*
    ;

equality_expr:
    relational_expr (('==' | '!=') relational_expr)*
    ;

relational_expr:
    shift_expr (('<' | '>' | '<=' | '>=') shift_expr)*
    ;

shift_expr:
    additive_expr (('<<' | '>>') additive_expr)*
    ;

additive_expr:
    multiplicative_expr (('+' | '-') multiplicative_expr)*
    ;

multiplicative_expr:
    unary_expr (('*' | '/' | '%') unary_expr)*
    ;

unary_expr:
    ('!' | '-')* postfix_expr
    ;

postfix_expr:
    primary_expr (('[' expr ']') | ('(' [expr_list] ')') | ('.' Name))*
    ;

primary_expr:
    Name
  | Integer
  | array_literal
  | '(' expr ')'
    ;

array_literal:
    '[' [expr_list] ']'
    ;

expr_list:
    expr (',' expr)*
    ;

assignment_op:
      '='
    | '-='
    | '+='
    | '/='
    | '*='
    | '>>='
    | '<<='
    | '^='
    | '|='
    | '&='
    ;

statement:
    variable
  | do_loop
  | if_statement
  | case_stmt
  | ?1 assignment_stmt
  | call_stmt
  | ret_stmt
    ;

assignment_stmt:
    Name assignment_op expr ';'
    ;

call_stmt:
    postfix_expr ';'
    ;

if_statement:
    'if' expr '{' statement* '}' ('else' (elif_clause | else_clause))*
    ;

elif_clause:
    'if' expr '{' statement* '}'
    ;

else_clause:
    '{' statement* '}'
    ;

do_loop:
    'do' (?1 do_cond_clause | do_iter_clause) '{' statement* '}'
    ;

do_cond_clause:
    expr
    ;

assignment:
    Name assignment_op expr
    ;

do_iter_clause:
    assignment [ 'by' expr ] '-->' expr
    ;

case_stmt:
    'case' '{' case_arm* '}'
    ;

case_arm:
    expr '<-' pattern ':' stmt_list ','
    ;

ret_stmt:
    'ret' [expr] ';'
    ;

stmt_list:
    statement+
    ;
